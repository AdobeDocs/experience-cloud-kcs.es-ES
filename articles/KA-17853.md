---
title: Compatibilidad con actividades de API externas
description: Descripción
solution: Campaign
product: Campaign
applies-to: Campaign Standard
keywords: KCS,Compatibilidad con actividades de API externas
resolution: Resolution
internal-notes: null
bug: false
article-created-by: Tanay Sharma .
article-created-date: 11/28/2022 1:31:59 PM
article-published-by: Tanay Sharma .
article-published-date: 11/28/2022 1:46:02 PM
version-number: 3
article-number: KA-17853
dynamics-url: https://adobe-ent.crm.dynamics.com/main.aspx?forceUCI=1&pagetype=entityrecord&etn=knowledgearticle&id=ad079903-216f-ed11-9562-6045bd006239
exl-id: 9a77814b-5cd3-4c61-adad-1ca1f77be2ec
source-git-commit: 75093d6221f06595d1dc5eccc365649b27f79204
workflow-type: tm+mt
source-wordcount: '200'
ht-degree: 1%

---

# Compatibilidad con actividades de API externas

## Descripción {#description}

<b>Entorno</b>
Estándar de contenido


<b>Problema/Síntomas</b>
El extremo de la API de REST de terceros acepta el siguiente formato JSON para pasar los datos.

<b>Carga útil real</b>:

`{"destination":"https://www.google.com/work/insights/123","domain":"google.com"}`



Sin embargo, ACS modifica el formato JSON, que no es aceptado por el punto final de la API REST de terceros.

<b>Carga útil modificada</b>:

`{“data”:{"destination":"https://www.google.com/work/insights/123","domain":"google.com"}}`




## Resolución {#resolution}




Existen dos factores que influyeron en la decisión de utilizar el formato:

1. El *datos* La parte solo se añade si hay una entrada *tabla temporal* generado por la actividad anterior y las filas de esa actividad *tabla temporal* se serializan en un *JSON* matriz. De ahí la necesidad de una *JSON* propiedad denominada *datos* y los datos serializados enviados como una matriz usando
2. La actividad permite enviar parámetros personalizados también a la API, que se añaden a la carga útil mediante una *parámetros* propiedad. Tenga en cuenta que estos se corrigen (se configuran una vez en la actividad durante la creación).




Este formato normalizado nos permitía tener un formato fijo sin ningún soporte de interfaz de usuario para personalizar cómo dar formato a esto según las especificaciones de API de terceros. La intención era utilizar una capa de traducción, como Adobe IO Runtime, AWS Lambda, etc., para traducir sobre la marcha las solicitudes/respuestas según fuera necesario.
