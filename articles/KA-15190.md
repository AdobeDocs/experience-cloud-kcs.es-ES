---
title: CAMPAIGN CLASSIC - [!UICONTROL Consulta incremental] recoge todos los registros en lugar de solo los nuevos
description: Descripción
solution: Campaign
product: Campaign
applies-to: Campaign Classic
keywords: KCS
resolution: Resolution
internal-notes: Ticket = TK197178
bug: true
article-created-by: Marta Zator
article-created-date: 5/10/2022 9:47:14 AM
article-published-by: Marta Zator
article-published-date: 5/10/2022 9:51:21 AM
version-number: 2
article-number: KA-15190
dynamics-url: https://adobe-ent.crm.dynamics.com/main.aspx?forceUCI=1&pagetype=entityrecord&etn=knowledgearticle&id=ad8bd527-46d0-ec11-a7b5-00224809c101
exl-id: f3dee0a7-8047-4949-9162-de95ba07fa7f
source-git-commit: dc1937169029c76dbce1ba513dd6430dffbc86c5
workflow-type: tm+mt
source-wordcount: '516'
ht-degree: 0%

---

# CAMPAIGN CLASSIC - [!UICONTROL Consulta incremental] recoge todos los registros en lugar de solo los nuevos

## Descripción

El cliente tiene varias consultas incrementales que no funcionan según lo esperado. En lugar de recoger solo los registros nuevos desde su última ejecución, están recogiendo todos los registros cada vez - como una normal [!UICONTROL Consulta] actividad.

## Resolución

El culpable es el [!UICONTROL Cleanup] flujo de trabajo.

El [!UICONTROL Consulta incremental] El flujo de trabajo de funciona de esta manera:

1. Mantener una tabla de historial con los resultados de iteraciones anteriores.
1. Recupere TODAS las filas de la consulta de destino.
1. Filtrar todas las filas presentes en la tabla del historial
1. Añada los resultados restantes a la tabla del historial para el siguiente filtrado de iteraciones.

Por lo tanto, este nombre de tabla de trabajo del historial es de la siguiente notación:

*wkfhistoworkflowid* activityName_

Ahora, para workflowIDs 0 (para clientes donde la variable `xtknewid` permite secuencias negativas), vemos que en realidad es:

*wkfhisto(uint)workflowId* activityName_

Aunque esto es correcto para la ejecución del flujo de trabajo.

Por ejemplo, la actividad incremental `incremental1` de flujo de trabajo ID=-1 creará una tabla `wkfhisto4294967295_incremental1`.

Lo que se echa de menos es el [!UICONTROL Cleanup] flujo de trabajo.

Aquí tiene un código que intenta eliminar las tablas de trabajo de los flujos de trabajo eliminados.

Un código específico aquí enumera todas las tablas wkfisto\*, extrae workflowId de sus nombres (de la convención anterior) y los elimina todos, excepto aquellos cuyos workflowID se encuentran en la tabla xtkworkflow.

Sin embargo, omite el `uint` parte.

Por lo tanto, intenta buscar un flujo de trabajo con 4294967295 de ID en lugar de volver a convertir esto en int. Dado que no se encuentra este flujo de trabajo, se elimina esta tabla. La próxima vez, cuando se ejecute este flujo de trabajo, [!UICONTROL Consulta incremental] La actividad de no encuentra una tabla de historial existente y la crea pensando en esta como la primera ejecución de la historia.

<b>Corrección:</b>

La corrección de este problema está disponible en la versión 20.1.1 de Adobe Campaign Classic (versión 9122 y posteriores).

<b>Soluciones alternativas que los clientes pueden utilizar:</b>

Solución 1: detenga el flujo de trabajo de limpieza y ejecútelo de forma intermitente para limpiar la base de datos y el disco duro hasta que la corrección esté disponible. No se recomienda si no tiene planificada una actualización.

Solución 2: suponga que la variable [!UICONTROL Consulta incremental] La actividad se ve afectada y soluciona el problema haciendo lo mismo que la actividad de [!UICONTROL Consulta incremental] lo hace creando un esquema persistente para mantener el contenido de la tabla del historial. Utilice una combinación de [!UICONTROL Consulta] y [!UICONTROL Actualización de datos] actividades para imitar el comportamiento. Esto deberá hacerse para todos los flujos de trabajo que requieran la consulta incremental.

Solución 3: suponga que la variable [!UICONTROL Consulta incremental] La actividad se ve afectada y puede solucionarla añadiendo un campo de auditoría (tsCreated/tsLastModified) al esquema en cuestión. La consulta incremental se convertirá a continuación en una actividad de consulta normal con una cláusula where como `tscreated GetDate()`.

Solución 4:

- Cree una nueva secuencia xtknewworkflowId e inicialícela con algo que esté lejos de los intervalos actuales de workflowId.
- Cambie el esquema xtkworkflow para utilizarlo `pkSequence`
- Pida al cliente que clone todos los flujos de trabajo afectados y elimine los originales.
- Una vez que el cliente esté listo para una actualización, elimine esta corrección volviendo a `xtknewId` para la creación del flujo de trabajo (para evitar sorpresas no deseadas).
